/*Copyright (c) 2008 Martin Raedlinger (mr@formatlos.de)Permission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE. */package com.formatlos.as3.lib.text.highlight {	import com.formatlos.as3.lib.text.highlight.style.IHighlightStyle;	import com.formatlos.as3.lib.text.highlight.style.SimpleHighlightStyle;	import flash.display.Sprite;	import flash.geom.Rectangle;	import flash.text.TextField;	/**	 * TextHighlighter provides a simple API to highlight specific text parts	 * with a custom style	 * 	 * @author Martin Raedlinger  (mr@formatlos.de)	 *	 * @example	 * The example shows how to use the TextHighlighter	 * <div class="listing">	 * <pre>	 * 	 * // highlight container	 * var highlight : Sprite = new Sprite();	 * addChild(highlight);	 * 	 * // create textfield	 * var textField : TextField = new TextField();	 * addChild(textField);	 * 	 * // apply text style and add text	 * ...	 * 	 * // highlight style	 * var style : IHighlightStyle = new SimpleHighlightStyle(0x00ff00, 0.5);	 * 	 * // highlighter	 * var textHighlighter : TextHighlighter = new TextHighlighter(textField, highlight, style);	 * textHighlighter.highlight(/far/gi);	 * textHighlighter.highlight("Duden", false);	 * </pre>	 * </div>	 * 	 */	public class TextHighlighter 	{		private var _tf : TextField;		private var _style : IHighlightStyle;		private var _highlightTarget : Sprite; 				/**		 * Creates a new TextHighlighter object		 * 		 * @param textField_ 		the textfield with the text to highlight		 * @param highlightTarget_ 	target for the highlight		 * @param style_ 			Style for the highlight		 */		public function TextHighlighter(textField_ : TextField, highlightTarget_ : Sprite, style_ : IHighlightStyle = null)		{			if(!style_) style_ = new SimpleHighlightStyle();						_tf = textField_;			_style = style_;			_highlightTarget = highlightTarget_;		}				/**		 * highlights the specified word in the textfield		 * 		 * @param word_ String or RegExp		 * @param clear_ clear old highlights or not		 */		public function highlight(word_ : *, clear_ : Boolean = true) : void		{			// clear old highlights			if(clear_) clear();									//			var pattern : RegExp;			var str : String = _tf.text;						// don't highlight scrolled text			if(_tf.scrollV != 1)			{				return;			}												if(word_ is String)			{				pattern = new RegExp(word_ as String, "g");				}			else if(word_ is RegExp)			{				pattern = word_ as RegExp;				}			else 			{				throw new Error("TextHighlighter: The word should either be String or RegExp");				return;			}	        			prepareForMetrics();	        			var result : Object;	        			while ((result = pattern.exec(str)) != null) 			{				highlightIndex(result.index, result.index + result.toString().length - 1);			}		}		private function prepareForMetrics() : void		{			// set height before getCharBoundaries			// otherwise it will probably return null			_tf.height = _tf.height;		}		/**		 *  puts a highlight at the specified index		 *  		 *  @param beginIndex_ 	start at this index		 *  @param endIndex_	highlight until this index		 */		public function highlightIndex(beginIndex_ : int = -1, endIndex_ : int = -1) : void		{			if(beginIndex_ < 0) beginIndex_ = 0;			if(endIndex_ < 0 || endIndex_ >= _tf.length) endIndex_ = _tf.length - 1;						// highlight single char			if(beginIndex_ == endIndex_)			{				highlightCharAt(beginIndex_);				return;			}						prepareForMetrics();						var beginLine : int = _tf.getLineIndexOfChar(beginIndex_);			var endLine : int = _tf.getLineIndexOfChar(endIndex_);			var rect : Rectangle;			var rectEnd : Rectangle;			var i : int = 0;			var m : int = endLine + 1;			var charPos : int = 0; 			var lineLen : int = 0; 						while(i < m)			{				lineLen = _tf.getLineLength(i);								if(i >= beginLine)				{					if(i == beginLine)					{						lineLen -= beginIndex_ - charPos;						charPos = beginIndex_;					}					if(i == endLine)					{						lineLen = endIndex_ - charPos;					}										if(lineLen == 0)					{						highlightCharAt(charPos);					}					else					{						try						{							rect = _tf.getCharBoundaries(charPos);							rectEnd = _tf.getCharBoundaries(charPos + lineLen - 1);							rect.width += rectEnd.x - rect.x + rectEnd.width;							_style.create(_highlightTarget, rect);						}						catch(error : Error)						{						}					}				}								// increase charPos				charPos += lineLen;				// increase lines					++i;			}		}						private function highlightCharAt(index_ : int) : void		{			_style.create(_highlightTarget, _tf.getCharBoundaries(index_));		}				/**		 * clear highlights in the highlightTarget		 */		public function clear() : void		{			_style.clear(_highlightTarget);		}		/**		 * finalize the object		 */		public function finalize() : void		{			if(_style)			{				_style.clear(_highlightTarget);				_style = null;			}						_tf = null;			_highlightTarget = null;		}	}}